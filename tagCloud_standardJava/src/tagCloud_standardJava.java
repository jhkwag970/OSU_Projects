import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;

/**
 * tag Cloud of given text file
 *
 * @author Jiyong Kwag and Yuan Hong
 *
 */
public class tagCloud_standardJava {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private tagCloud_standardJava() {

    }

    private static class compareInt
            implements Comparator<Map.Entry<String, Integer>> {

        @Override
        public int compare(Entry<String, Integer> o1,
                Entry<String, Integer> o2) {
            return o2.getValue().compareTo(o1.getValue());
        }

    }

    private static class compareStr implements Comparator<String> {

        @Override
        public int compare(String o1, String o2) {
            int cmp = o1.toLowerCase().compareTo(o2.toLowerCase());
            if (cmp != 0) {
                return cmp;
            }

            return o2.compareTo(o1);
        }

    }

    public static void main(String[] args) {

        String input = "", output = "";
        int n = 0;
        Map<String, Integer> wordCount = new HashMap<String, Integer>();

        Comparator<String> sortStr = new compareStr();
        Comparator<Map.Entry<String, Integer>> sortInt = new compareInt();

        PriorityQueue<Map.Entry<String, Integer>> sortByInt = new PriorityQueue<Map.Entry<String, Integer>>(
                sortInt);
        SortedMap<String, Integer> sortByString = new TreeMap<String, Integer>(
                sortStr);
        //////
        BufferedReader in = new BufferedReader(
                new InputStreamReader(System.in));
        try {
            System.out.println("Enter the input file: ");
            input = in.readLine();

        } catch (IOException e) {
            System.err.println("Error receiving the input file");
            return;
        }

        try {
            System.out.println("Enter the output file name: ");
            output = in.readLine();
        } catch (IOException e) {

            System.err.println("Error receiving the output file");
            return;
        }

        try {
            System.out.println("Enter the value: ");
            n = Integer.parseInt(in.readLine());
            while (n < 0) {
                System.out.println("Number bust be an positive integer");
                n = Integer.parseInt(in.readLine());
            }
        } catch (IOException e) {
            System.err.println("Error in receiving the value number");
            return;
        }

        BufferedReader inFile;
        PrintWriter outFile;
        try {
            inFile = new BufferedReader(new FileReader(input));
//            outFile = new PrintWriter(
//                    new BufferedWriter(new FileWriter(output)));
        } catch (IOException e) {
            System.err.println("Error opening the file");
            return;
        }

        countingWords(inFile, wordCount);
        if (n > wordCount.size()) {
            System.err.print(
                    "Number of words in input file is less than number of words required for output");
            return;
        }

        try {
            outFile = new PrintWriter(
                    new BufferedWriter(new FileWriter(output)));
            inFile.close();
        } catch (IOException e) {
            System.err.println("Error opening the html file");
            return;
        }

        String maxAndMin = sortingWords(wordCount, sortByInt, sortByString, n);

        creatHtml(sortByString, outFile, output, maxAndMin);

        try {
            in.close();
            outFile.close();
        } catch (IOException e) {
            System.err.println("Error closing the file");
        }

    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * @param sort
     *            sortedMap that contains the alphabetically sorted word index
     * @param out
     *            the output stream
     * @param txt
     *            name of term pages, in HTML format
     * @param maxAndmin
     *            maximum and minimum count for of the sortedMap
     * @updates out.content
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    public static void creatHtml(SortedMap<String, Integer> sort,
            PrintWriter out, String txt, String maxAndmin) {

        out.println("<html>");

        out.println("<head>");
        out.println("<title>" + "Top " + sort.size() + " words in " + txt
                + "</title>");
        out.println(
                "<link href=\"http://web.cse.ohio-state.edu/software/2231/web-sw2/assignments/projects/tag-cloud-generator/data/tagcloud.css\" rel =\"stylesheet\" type=\"text/css\"");
        out.println("</head>");

        out.println("<body>");

        out.println("<h2> Top " + sort.size() + " words in " + txt + "</h2>");
        out.println("<hr>");
        out.println("<div class = \"cdiv\">");
        out.println("<p class=\"cbox\">");

        int index = maxAndmin.indexOf(';');
        String maxS = "", minS = "";
        maxS = maxAndmin.substring(0, index);
        minS = maxAndmin.substring(index + 1);

        int max = Integer.parseInt(maxS), min = Integer.parseInt(minS);

        for (Map.Entry<String, Integer> wordList : sort.entrySet()) {
            String word = wordList.getKey();
            int cnt = sort.get(word);
            int range = 48;

            if (max - min != 0) {
                range = (37 * (cnt - min) / (max - min)) + 11;
            }

            out.println("<span style=\"cursor:default\" class=\"" + "f" + range
                    + "\" title=\"count: " + cnt + "\">" + word + "</span>");

        }

        out.println("</p>");
        out.println("</div>");
        out.println("</body>");
        out.println("</html>");

    }

    /**
     * countingWords is for inserting the separated word and its number of uses
     * into map.
     *
     * @param fileIn
     *            BufferedReader file
     * @param word
     *            the map that insert the word and its number of uses
     * @requires fileIn should not be empty
     * @update word
     * @ensures word should not be empty
     *
     */
    public static void countingWords(BufferedReader fileIn,
            Map<String, Integer> word) {

        Set<Character> separatorSet = new HashSet<Character>();
        String separator = "\\ \t\n\r,-.!?[]';:/()@&~`\"";

        for (int i = 0; i < separator.length(); i++) {
            separatorSet.add(separator.charAt(i));
        }
        String line;
        try {
            line = fileIn.readLine();
            while (line != null) {
                int pos = 0;
                while (pos < line.length()) {
                    String token = nextWordOrSeparator(line, pos, separatorSet);
                    if (!separatorSet.contains(token.charAt(0))) {
                        if (word.containsKey(token)) {
                            int num = word.get(token);
                            num++;
                            word.put(token, num);
                        } else {
                            word.put(token, 1);
                        }
                    }
                    pos += token.length();
                }
                line = fileIn.readLine();
            }

        } catch (IOException e1) {
            e1.printStackTrace();
            System.err.print("Error in reading lines");
            return;
        }
    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    private static String nextWordOrSeparator(String text, int pos,
            Set<Character> separators) {
        int cnt = pos;
        String result = "";

        if (separators.contains(text.charAt(pos))) {
            while (cnt < text.length()
                    && separators.contains(text.charAt(cnt))) {
                cnt++;
            }
        } else {
            while (cnt < text.length()
                    && !separators.contains(text.charAt(cnt))) {
                cnt++;
            }
        }
        result = text.substring(pos, cnt);
        return result;
    }

    /**
     * Sorting the {@code sortByStr} with top {@code n} counts in the
     * {@code sortByInt} and returns the String that contains the maximum and
     * mininum number of count in {@code sortByStr} separated by character ';'.
     *
     * @param wordCount
     *            map that contains the words and the counts of each word
     * @param mapSortedByInt
     *            PriorityQueue based on greatest to smallest number
     * @param mapSortedByString
     *            sortedMap based on alphabetical order
     * @param n
     *            number of words that will go into the {@code sortByStr}
     * @return maximum and minimum number of count in the {@code sortByStr}
     * @updates sortByStr
     * @requires |wordCount| > 0 and |sortByStr| > 0
     * @ensures "maximum number of counts;minimum number of counts" if n == 0,
     *          then "0;0"
     *
     */
    private static String sortingWords(Map<String, Integer> wordCount,
            PriorityQueue<Map.Entry<String, Integer>> mapSortedByInt,
            SortedMap<String, Integer> mapSortedByString, int n) {
        String maxAndMin = "0;0";

        for (Map.Entry<String, Integer> p : wordCount.entrySet()) {
            mapSortedByInt.add(p);
        }

        for (int i = 0; i < n; i++) {
            Map.Entry<String, Integer> p = mapSortedByInt.remove();
            int cnt = p.getValue();
            String word = p.getKey();

            if (i == 0) {
                maxAndMin = p.getValue().toString() + ";";
            }
            if (i == n - 1) {
                maxAndMin += p.getValue().toString();
            }

            mapSortedByString.put(word, cnt);
        }
        return maxAndMin;
    }

}
